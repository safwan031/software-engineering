<a href="https://github.com/drshahizan/software-engineering/stargazers"><img src="https://img.shields.io/github/stars/drshahizan/software-engineering" alt="Stars Badge"/></a>
<a href="https://github.com/drshahizan/software-engineering/network/members"><img src="https://img.shields.io/github/forks/drshahizan/software-engineering" alt="Forks Badge"/></a>
<a href="https://github.com/drshahizan/software-engineering/pulls"><img src="https://img.shields.io/github/issues-pr/drshahizan/software-engineering" alt="Pull Requests Badge"/></a>
<a href="https://github.com/drshahizan/software-engineering"><img src="https://img.shields.io/github/issues/drshahizan/software-engineering" alt="Issues Badge"/></a>
<a href="https://github.com/drshahizan/software-engineering/graphs/contributors"><img alt="GitHub contributors" src="https://img.shields.io/github/contributors/drshahizan/software-engineering?color=2b9348"></a>
![Visitors](https://api.visitorbadge.io/api/visitors?path=https%3A%2F%2Fgithub.com%2Fdrshahizan%2Fsoftware-engineering&labelColor=%23d9e3f0&countColor=%23697689&style=flat)


Don't forget to hit the :star: if you like this repo.


Module 2: Software Process Model

Group NikoNikoNee
1. Jaslene Yu
2. Nicole Lim Tze Yee
3. Tiew Chuan Rong
4. Wong Jun Ji



# Module 2: Software Process Model

### Contents:
#### Notes
- Software process models
- Plan Driven and Agile process
- Waterfall Model
- Incremental model
- Reuse oriented software engineering
- Spiral model: coping with change
- The Rational Unified Process(RUP)

### Others
- [Software Engineering | Introduction to Software Engineering](https://www.geeksforgeeks.org/software-engineering-introduction-to-software-engineering/)


## The Importance of Software Engineering

Software engineering is an essential field of study that deals with the design, development, and maintenance of software applications. It plays a vital role in the development and success of modern technology. Here are some of the reasons why software engineering is important:


## Contribution üõ†Ô∏è
Please create an [Issue](https://github.com/drshahizan/software-engineering/issues) for any improvements, suggestions or errors in the content.

You can also contact me using [Linkedin](https://www.linkedin.com/in/drshahizan/) for any other queries or feedback.

[![Visitors](https://api.visitorbadge.io/api/visitors?path=https%3A%2F%2Fgithub.com%2Fdrshahizan&labelColor=%23697689&countColor=%23555555&style=plastic)](https://visitorbadge.io/status?path=https%3A%2F%2Fgithub.com%2Fdrshahizan)
![](https://hit.yhype.me/github/profile?user_id=81284918)



###  What is Software Process?
Software process is a set of related activities that leads to the production of the software. There are different ways to explain software processes but all of them involve:
<ul>
  <li>Specification
  <li>Design
  <li>Implementation
  <li>Validation
  <li>Evolution
</ul>
The software process is critical to ensuring that software is developed and maintained in a consistent and structured manner. By following a well-defined process, software development teams can ensure that the software is of high quality, meets the needs of the end-users, and is delivered on time and within budget.

<b>A software process model</b> is a structured approach to software development that defines the sequence and flow of activities that should be followed in order to build high-quality software. Some common software process models are such as waterfall model, agile model, spiral model, DevOps model, etc... Each software process model has its own strengths and weaknesses, and the choice of model will depend on the specific needs and requirements of the project.

#### Software process model
<table>
  <tr>
    <th>Models</th>
    <th>Waterfall</th>
    <th>Incremental development</th>
    <th>Reuse-oriented</th>
  </tr>
  <tr>    
    <th>Process</th>
    <th><img width="309" alt="image" src="https://user-images.githubusercontent.com/129235052/233090033-86acb5bc-c377-4509-a132-3234d6ec0646.png">
</th>
    <td><img width="343" alt="image" src="https://user-images.githubusercontent.com/129235052/233090401-82641afe-9332-4f0e-8b11-e33798f40e7e.png">
</td>
    <td><img width="371" alt="image" src="https://user-images.githubusercontent.com/129235052/233090490-9798fc3a-7032-4592-91b0-81525983ddf8.png">
</td>
  </tr>
  <tr>
    <th>Description</th>
    <td>
      <ul>
        <li>plan-driven</li>
        <li>sequential phases</li>
        <li>next step rely on the previous step</li>
        <li>distinct phases of specification and development</li>
        <li>used for large system</li>
      </ul>
    </td>
    <td>
      <ul>
        <li>plan-driven/agile</li>
        <li>built piece-by-piece (subsystem)</li>
      </ul>
    </td>
    <td>
      <ul>
        <li>plan-driven/agile</li>
        <li>integrated from existing components or COTS (Comersial-off-the-shelf)</li>
      </ul>
    </td>
  </tr>
  <tr>
    <th>Benefits</th>
    <td>
      <ul> 
        <li>Structured approach: step-by-step, each phase is completed       thoroughly before moving to the next phase</li>
        <li>Clear requirements: all requirements be defined and documented upfront</li>
        <li>Predictable outcomes: easier to estimate project timelines and costs, especially for large projects or projects with multiple stakeholders</li>
        <li>Emphasizes documentation: clear record of the project's progress, decisions, and outcomes</li>
      </ul>
    </td>
    <td> <ul>
        <li>reduce cost</li>
        <li>easier to get customers' feedback</li>
        <li>rapid delivery and deployment</li>
        <li>distinct phases of specification and development</li>
      </ul>
    </td>
    <td> 
      <ul>
        <li>reduce overall cost</li>
        <li>save time</li>
       </ul>
    </td>
  </tr>
  <tr>
    <th>Drawbacks</th>
    <td>
       <ul>
        <li>cannot go back</li>
        <li>changes is limited</li>
       </ul>
    </td>
    <td>
      <ul>
        <li>process not visible</li>
        <li>structure tends to degrade(final costs exceed the initial cost projected)</li>
       </ul>
    </td>
    <td>
      <ul>
        <li>Limited availability of reusable components</li>
        <li>Compatibility issues: occurs when integrating existing components into a new system.</li>
        <li>Increased complexity: integration of different components results in more difficult maintenance of system.</li>
        <li>Limited creativity and innovation</li>
       </ul>
    </td>
  </tr>
    

</table>

### Step 1: Software Specification
<img width="516" alt="image" src="https://user-images.githubusercontent.com/129235052/233095789-c096222d-b797-4bca-9d91-fc52204843e2.png">

Software specification refers to the <b>process of defining the requirements and specifications</b> for a software system. It involves capturing the needs and expectations of the stakeholders, including the end-users, and documenting them in a clear and unambiguous manner. 

The software specification process typically involves the following steps:

#### 1. Requirements gathering: 
This involves identifying the needs and **expectations of the stakeholders**, including the end-users, through interviews, surveys, and other techniques. The requirements should be captured in a clear and concise manner, avoiding any ambiguity or vagueness.

#### 2. Requirements analysis: 
Once the requirements have been gathered, they need to be **analyzed** to ensure that they are complete, consistent, and feasible. Any conflicts or inconsistencies in the requirements should be resolved at this stage.

#### 3. Requirements documentation: 
The requirements should be **documented** in a formal specification document that serves as the reference for the development team. The document should include a description of the system, its features, and its functions, as well as any constraints or assumptions.

#### 4. Validation and verification: 
The software specification should be **validated and verified** to ensure that it **meets the expectations** of the stakeholders. This can be done through reviews, inspections, and testing.



The software **specification document** typically includes the following information:

<li> Functional requirements: These describe the features and functions that the software system should provide.

<li> Non-functional requirements: These describe the quality attributes of the system, such as performance, reliability, security, and usability.

<li> Constraints and assumptions: These describe any limitations or assumptions that the development team needs to consider when designing and developing the system.

<li> User interface design: This describes the layout and design of the user interface, including any input and output formats.

<li> System architecture: This describes the overall structure of the system, including the hardware and software components, and how they interact with each other.

Overall, software specification is a critical part of the software development process, ensuring that the software system meets the needs and expectations of the stakeholders and is delivered on time and within budget. </li>

  
### Step 2: Software Design and Implementation
<img width="419" alt="image" src="https://user-images.githubusercontent.com/129235052/233099489-3b3c53cd-f48f-43f0-9747-7736250ac3cc.png">
<b>Software design</b> refers to the process of defining the architecture, components, interfaces, and other characteristics of a software system. <b>Software implementation</b> refers to the process of writing the code and integrating the various components to create a working software system.


Here are some details about software design and implementation:

**Software Design:**
<li>Architecture Design: The first step in software design is to define the overall architecture of the software system. This involves defining the different components of the system, how they interact with each other, and the overall structure of the system.

<li>Component Design: Once the overall architecture has been defined, the next step is to design the individual components of the system. This involves defining the interfaces, data structures, and algorithms that will be used to implement each component.

<li>Interface Design: Interfaces are the means by which different components of the system communicate with each other. Interface design involves defining the input and output parameters, as well as the protocols and data formats that will be used to transmit data between the components.

<li>Data Design: Data design involves defining the data structures that will be used to store and manipulate data within the system. This includes defining the types of data, their format, and the algorithms that will be used to manipulate them.</li>

<br>
**Software Implementation:**
<li>Coding: Once the software design has been completed, the next step is to write the code that will implement the design. This involves using a programming language to translate the design into a working software system.

<li>Testing: After the code has been written, it needs to be tested to ensure that it works as intended. This involves testing individual components, as well as the system as a whole.

<li>Integration: Once the individual components have been tested and verified, they need to be integrated into a working software system. This involves connecting the various components and ensuring that they work together seamlessly.

<li>Maintenance: Once the software system has been deployed, it will need to be maintained over time. This involves fixing any bugs that are discovered, updating the software to address new requirements, and ensuring that the software continues to function as intended. </li>


### Step 2: Software Validation

Software validation is an essential component of the software process model that aims to ensure that the developed software meets its intended purpose and satisfies the specified requirements. It is the process of checking whether the software meets the intended requirements and specifications and is capable of performing as expected in its intended environment.
The goal of software validation is to ensure that the software meets its intended purpose and satisfies the specified requirements. By validating the software, development teams can ensure that they deliver high-quality software that meets the needs of end-users and stakeholders.
<img width="463" alt="image" src="https://user-images.githubusercontent.com/129235052/235437791-70e0413c-c61e-41f1-a2ba-cea7e2bd9272.png">


Software validation typically involves the following activities:

<li>**Requirement validation:** This involves reviewing and verifying the requirements and specifications to ensure that they are complete, and correct. This involves reviewing the software design to ensure that it meets the specified requirements and is capable of delivering the intended functionality. It helps to ensure that the software is designed to be reliable, maintainable, and scalable.</li>

<li>**Testing:** This involves executing various test cases to verify that the software meets the specified requirements and performs as expected in its intended environment. It includes functional testing, performance testing, and security testing, among others.</li>

<li>**User acceptance testing:** This involves allowing end-users to test the software to ensure that it meets their needs and is usable.</li>

